{"name":"Raymond","tagline":"Handlebars for golang","body":"# raymond [![Build Status](https://secure.travis-ci.org/aymerick/raymond.svg?branch=master)](http://travis-ci.org/aymerick/raymond) [![GoDoc](https://godoc.org/github.com/aymerick/raymond?status.svg)](http://godoc.org/github.com/aymerick/raymond)\r\n\r\nHandlebars for [golang](https://golang.org) with the same features as [handlebars.js](http://handlebarsjs.com) `3.0`.\r\n\r\nThe full API documentation is available here: <http://godoc.org/github.com/aymerick/raymond>.\r\n\r\n\r\n## Quick Start\r\n\r\n    $ go get github.com/aymerick/raymond\r\n\r\nThe quick and dirty way of rendering a handlebars template:\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n    \"fmt\"\r\n\r\n    \"github.com/aymerick/raymond\"\r\n)\r\n\r\nfunc main() {\r\n    tpl := `<div class=\"entry\">\r\n  <h1>{{title}}</h1>\r\n  <div class=\"body\">\r\n    {{body}}\r\n  </div>\r\n</div>\r\n`\r\n\r\n    ctx := map[string]string{\r\n        \"title\": \"My New Post\",\r\n        \"body\":  \"This is my first post!\",\r\n    }\r\n\r\n    result, err := raymond.Render(tpl, ctx)\r\n    if err != nil {\r\n        panic(\"Please fill a bug :)\")\r\n    }\r\n\r\n    fmt.Print(result)\r\n}\r\n```\r\n\r\nDisplays:\r\n\r\n```html\r\n<div class=\"entry\">\r\n  <h1>My New Post</h1>\r\n  <div class=\"body\">\r\n    This is my first post!\r\n  </div>\r\n</div>\r\n```\r\n\r\nPlease note that the template will be parsed everytime you call `Render()` function. So you probably want to read the next section.\r\n\r\n\r\n## Correct Usage\r\n\r\nTo avoid parsing a template several times, use the `Parse()` and `Exec()` functions:\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n    \"fmt\"\r\n\r\n    \"github.com/aymerick/raymond\"\r\n)\r\n\r\nfunc main() {\r\n    source := `<div class=\"entry\">\r\n  <h1>{{title}}</h1>\r\n  <div class=\"body\">\r\n    {{body}}\r\n  </div>\r\n</div>\r\n`\r\n\r\n    ctxList := []map[string]string{\r\n        {\r\n            \"title\": \"My New Post\",\r\n            \"body\":  \"This is my first post!\",\r\n        },\r\n        {\r\n            \"title\": \"Here is another post\",\r\n            \"body\":  \"This is my second post!\",\r\n        },\r\n    }\r\n\r\n    // parse template\r\n    tpl, err := raymond.Parse(source)\r\n    if err != nil {\r\n        panic(err)\r\n    }\r\n\r\n    for _, ctx := range ctxList {\r\n        // render template\r\n        result, err := tpl.Exec(ctx)\r\n        if err != nil {\r\n            panic(err)\r\n        }\r\n\r\n        fmt.Print(result)\r\n    }\r\n}\r\n\r\n```\r\n\r\nDisplays:\r\n\r\n```html\r\n<div class=\"entry\">\r\n  <h1>My New Post</h1>\r\n  <div class=\"body\">\r\n    This is my first post!\r\n  </div>\r\n</div>\r\n<div class=\"entry\">\r\n  <h1>Here is another post</h1>\r\n  <div class=\"body\">\r\n    This is my second post!\r\n  </div>\r\n</div>\r\n```\r\n\r\nYou can use `MustParse()` and `MustExec()` functions if you don't want to deal with errors:\r\n\r\n```go\r\n// parse template\r\ntpl := raymond.MustParse(source)\r\n\r\n// render template\r\nresult := tpl.MustExec(ctx)\r\n```\r\n\r\n\r\n## Context\r\n\r\nThe rendering context can contain any type of values, including `array`, `slice`, `map`, `struct` and `func`.\r\n\r\nWhen using structs, be warned that only exported fields are accessible:\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n  \"fmt\"\r\n\r\n  \"github.com/aymerick/raymond\"\r\n)\r\n\r\nfunc main() {\r\n    source := `<div class=\"post\">\r\n  <h1>By {{Author.FirstName}} {{Author.LastName}}</h1>\r\n  <div class=\"body\">{{Body}}</div>\r\n\r\n  <h1>Comments</h1>\r\n\r\n  {{#each Comments}}\r\n  <h2>By {{Author.FirstName}} {{Author.LastName}}</h2>\r\n  <div class=\"body\">{{Body}}</div>\r\n  {{/each}}\r\n</div>`\r\n\r\n    type Post struct {\r\n        Author   Person\r\n        Body     string\r\n        Comments []Comment\r\n    }\r\n\r\n    type Person struct {\r\n        FirstName string\r\n        LastName  string\r\n    }\r\n\r\n    type Comment struct {\r\n        Author Person\r\n        Body   string\r\n    }\r\n\r\n    ctx := Post{\r\n        Person{\"Jean\", \"Valjean\"},\r\n        \"Life is difficult\",\r\n        []Comment{\r\n            Comment{\r\n                Person{\"Marcel\", \"Beliveau\"},\r\n                \"LOL!\",\r\n            },\r\n        },\r\n    }\r\n\r\n    output := raymond.MustRender(source, ctx)\r\n\r\n    fmt.Print(output)\r\n}\r\n```\r\n\r\nOutput:\r\n\r\n```html\r\n<div class=\"post\">\r\n  <h1>By Jean Valjean</h1>\r\n  <div class=\"body\">Life is difficult</div>\r\n\r\n  <h1>Comments</h1>\r\n\r\n  <h2>By Marcel Beliveau</h2>\r\n  <div class=\"body\">LOL!</div>\r\n</div>\r\n```\r\n\r\n\r\n## HTML Escaping\r\n\r\nBy default, the result of a mustache expression is HTML escaped. Use the triple mustache `{{{` to output unescaped values.\r\n\r\n```go\r\nsource := `<div class=\"entry\">\r\n  <h1>{{title}}</h1>\r\n  <div class=\"body\">\r\n    {{{body}}}\r\n  </div>\r\n</div>\r\n`\r\n\r\nctx := map[string]string{\r\n    \"title\": \"All about <p> Tags\",\r\n    \"body\":  \"<p>This is a post about &lt;p&gt; tags</p>\",\r\n}\r\n\r\ntpl := raymond.MustParse(source)\r\nresult := tpl.MustExec(ctx)\r\n\r\nfmt.Print(result)\r\n```\r\n\r\nOutput:\r\n\r\n```html\r\n<div class=\"entry\">\r\n  <h1>All about &lt;p&gt; Tags</h1>\r\n  <div class=\"body\">\r\n    <p>This is a post about &lt;p&gt; tags</p>\r\n  </div>\r\n</div>\r\n```\r\n\r\nWhen returning HTML from a helper, you should return a `SafeString` if you don't want it to be escaped by default. When using `SafeString` all unknown or unsafe data should be manually escaped with the `Escape` method.\r\n\r\n```go\r\nraymond.RegisterHelper(\"link\", func(url, text string) raymond.SafeString {\r\n    return raymond.SafeString(\"<a href='\" + raymond.Escape(url) + \"'>\" + raymond.Escape(text) + \"</a>\")\r\n})\r\n\r\ntpl := raymond.MustParse(\"{{link url text}}\")\r\n\r\nctx := map[string]string{\r\n    \"url\":  \"http://www.aymerick.com/\",\r\n    \"text\": \"This is a <em>cool</em> website\",\r\n}\r\n\r\nresult := tpl.MustExec(ctx)\r\nfmt.Print(result)\r\n```\r\n\r\nOutput:\r\n\r\n```html\r\n<a href='http://www.aymerick.com/'>This is a &lt;em&gt;cool&lt;/em&gt; website</a>\r\n```\r\n\r\n\r\n## Helpers\r\n\r\nHelpers can be accessed from any context in a template. You can register a helper with the `RegisterHelper` function.\r\n\r\nFor example:\r\n\r\n```html\r\n<div class=\"post\">\r\n  <h1>By {{fullName author}}</h1>\r\n  <div class=\"body\">{{body}}</div>\r\n\r\n  <h1>Comments</h1>\r\n\r\n  {{#each comments}}\r\n  <h2>By {{fullName author}}</h2>\r\n  <div class=\"body\">{{body}}</div>\r\n  {{/each}}\r\n</div>\r\n```\r\n\r\nWith this context and helper:\r\n\r\n```go\r\nctx := map[string]interface{}{\r\n    \"author\": map[string]string{\"firstName\": \"Jean\", \"lastName\": \"Valjean\"},\r\n    \"body\":   \"Life is difficult\",\r\n    \"comments\": []map[string]interface{}{{\r\n        \"author\": map[string]string{\"firstName\": \"Marcel\", \"lastName\": \"Beliveau\"},\r\n        \"body\":   \"LOL!\",\r\n    }},\r\n}\r\n\r\nraymond.RegisterHelper(\"fullName\", func(person map[string]string) string {\r\n    return person[\"firstName\"] + \" \" + person[\"lastName\"]\r\n})\r\n```\r\n\r\nOutputs:\r\n\r\n```html\r\n<div class=\"post\">\r\n  <h1>By Jean Valjean</h1>\r\n  <div class=\"body\">Life is difficult</div>\r\n\r\n  <h1>Comments</h1>\r\n\r\n  <h2>By Marcel Beliveau</h2>\r\n  <div class=\"body\">LOL!</div>\r\n</div>\r\n```\r\n\r\nHelper arguments can be any type.\r\n\r\nThe following example uses structs instead of maps and produces the same output as the previous one:\r\n\r\n```html\r\n<div class=\"post\">\r\n  <h1>By {{fullName Author}}</h1>\r\n  <div class=\"body\">{{Body}}</div>\r\n\r\n  <h1>Comments</h1>\r\n\r\n  {{#each Vomments}}\r\n  <h2>By {{fullName Author}}</h2>\r\n  <div class=\"body\">{{Body}}</div>\r\n  {{/each}}\r\n</div>\r\n```\r\n\r\nWith this context and helper:\r\n\r\n```go\r\ntype Post struct {\r\n    Author   Person\r\n    Body     string\r\n    Comments []Comment\r\n}\r\n\r\ntype Person struct {\r\n    FirstName string\r\n    LastName  string\r\n}\r\n\r\ntype Comment struct {\r\n    Author Person\r\n    Body   string\r\n}\r\n\r\nctx := Post{\r\n    Person{\"Jean\", \"Valjean\"},\r\n    \"Life is difficult\",\r\n    []Comment{\r\n        Comment{\r\n            Person{\"Marcel\", \"Beliveau\"},\r\n            \"LOL!\",\r\n        },\r\n    },\r\n}\r\n\r\nRegisterHelper(\"fullName\", func(person Person) string {\r\n    return person.FirstName + \" \" + person.LastName\r\n})\r\n```\r\n\r\n\r\n### Template Helpers\r\n\r\nYou can register a helper on a specific template, and in that case that helper will be available to that template only:\r\n\r\n```go\r\ntpl := raymond.MustParse(\"User: {{fullName user.firstName user.lastName}}\")\r\n\r\ntpl.RegisterHelper(\"fullName\", func(firstName, lastName string) string {\r\n  return firstName + \" \" + lastName\r\n})\r\n```\r\n\r\n\r\n### Built-In Helpers\r\n\r\nThose built-in helpers are available to all templates.\r\n\r\n\r\n#### The `if` block helper\r\n\r\nYou can use the `if` helper to conditionally render a block. If its argument returns `false`, `nil`, `0`, `\"\"`, an empty array, an empty slice or an empty map, then raymond will not render the block.\r\n\r\n```html\r\n<div class=\"entry\">\r\n  {{#if author}}\r\n    <h1>{{firstName}} {{lastName}}</h1>\r\n  {{/if}}\r\n</div>\r\n```\r\n\r\nWhen using a block expression, you can specify a template section to run if the expression returns a falsy value. That section, marked by `{{else}}` is called an \"else section\".\r\n\r\n```html\r\n<div class=\"entry\">\r\n  {{#if author}}\r\n    <h1>{{firstName}} {{lastName}}</h1>\r\n  {{else}}\r\n    <h1>Unknown Author</h1>\r\n  {{/if}}\r\n</div>\r\n```\r\n\r\nYou can chain several blocks. For example that template:\r\n\r\n```html\r\n{{#if isActive}}\r\n  <img src=\"star.gif\" alt=\"Active\">\r\n{{else if isInactive}}\r\n  <img src=\"cry.gif\" alt=\"Inactive\">\r\n{{else}}\r\n  <img src=\"wat.gif\" alt=\"Unknown\">\r\n{{/if}}\r\n```\r\n\r\nWith that context:\r\n\r\n```go\r\nctx := map[string]interface{}{\r\n    \"isActive\":   false,\r\n    \"isInactive\": false,\r\n}\r\n```\r\n\r\nOutputs:\r\n\r\n```html\r\n <img src=\"wat.gif\" alt=\"Unknown\">\r\n```\r\n\r\n\r\n#### The `unless` block helper\r\n\r\nYou can use the `unless` helper as the inverse of the `if` helper. Its block will be rendered if the expression returns a falsy value.\r\n\r\n```html\r\n<div class=\"entry\">\r\n  {{#unless license}}\r\n  <h3 class=\"warning\">WARNING: This entry does not have a license!</h3>\r\n  {{/unless}}\r\n</div>\r\n```\r\n\r\n\r\n#### The `each` block helper\r\n\r\nYou can iterate over an array, a slice, a map or a struct instance using this built-in `each` helper. Inside the block, you can use `this` to reference the element being iterated over.\r\n\r\nFor example:\r\n\r\n```html\r\n<ul class=\"people\">\r\n  {{#each people}}\r\n    <li>{{this}}</li>\r\n  {{/each}}\r\n</ul>\r\n```\r\n\r\nWith this context:\r\n\r\n```go\r\nmap[string]interface{}{\r\n    \"people\": []string{\r\n        \"Marcel\", \"Jean-Claude\", \"Yvette\",\r\n    },\r\n}\r\n```\r\n\r\nOutputs:\r\n\r\n```html\r\n<ul class=\"people\">\r\n  <li>Marcel</li>\r\n  <li>Jean-Claude</li>\r\n  <li>Yvette</li>\r\n</ul>\r\n```\r\n\r\nYou can optionally provide an `{{else}}` section which will display only when the passed argument is an empty array, an empty slice or an empty map (a `struct` instance is never considered empty).\r\n\r\n```html\r\n{{#each paragraphs}}\r\n  <p>{{this}}</p>\r\n{{else}}\r\n  <p class=\"empty\">No content</p>\r\n{{/each}}\r\n```\r\n\r\nWhen looping through items in `each`, you can optionally reference the current loop index via `{{@index}}`.\r\n\r\n```html\r\n{{#each array}}\r\n  {{@index}}: {{this}}\r\n{{/each}}\r\n```\r\n\r\nAdditionally for map and struct instance iteration, `{{@key}}` references the current map key or struct field name:\r\n\r\n```html\r\n{{#each map}}\r\n  {{@key}}: {{this}}\r\n{{/each}}\r\n```\r\n\r\nThe first and last steps of iteration are noted via the `@first` and `@last` variables.\r\n\r\n\r\n#### The `with` block helper\r\n\r\nYou can shift the context for a section of a template by using the built-in `with` block helper.\r\n\r\n```html\r\n<div class=\"entry\">\r\n  <h1>{{title}}</h1>\r\n\r\n  {{#with author}}\r\n  <h2>By {{firstName}} {{lastName}}</h2>\r\n  {{/with}}\r\n</div>\r\n```\r\n\r\nWith this context:\r\n\r\n```go\r\nmap[string]interface{}{\r\n    \"title\": \"My first post!\",\r\n    \"author\": map[string]string{\r\n        \"firstName\": \"Jean\",\r\n        \"lastName\":  \"Valjean\",\r\n    },\r\n}\r\n```\r\n\r\nOutputs:\r\n\r\n```html\r\n<div class=\"entry\">\r\n  <h1>My first post!</h1>\r\n\r\n  <h2>By Jean Valjean</h2>\r\n</div>\r\n```\r\n\r\nYou can optionally provide an `{{else}}` section which will display only when the passed argument is falsy.\r\n\r\n```html\r\n{{#with author}}\r\n  <p>{{name}}</p>\r\n{{else}}\r\n  <p class=\"empty\">No content</p>\r\n{{/with}}\r\n```\r\n\r\n\r\n#### The `lookup` helper\r\n\r\nThe `lookup` helper allows for dynamic parameter resolution using handlebars variables.\r\n\r\n```html\r\n{{#each bar}}\r\n  {{lookup ../foo @index}}\r\n{{/each}}\r\n```\r\n\r\n\r\n#### The `log` helper\r\n\r\nThe `log` helper allows for logging while rendering a template.\r\n\r\n```html\r\n{{log \"Look at me!\"}}\r\n```\r\n\r\nNote that the handlebars.js `@level` variable is not supported.\r\n\r\n\r\n### Block Helpers\r\n\r\nBlock helpers make it possible to define custom iterators and other functionality that can invoke the passed block with a new context.\r\n\r\n\r\n#### Block Evaluation\r\n\r\nAs an example, let's define a block helper that adds some markup to the wrapped text.\r\n\r\n```html\r\n<div class=\"entry\">\r\n  <h1>{{title}}</h1>\r\n  <div class=\"body\">\r\n    {{#bold}}{{body}}{{/bold}}\r\n  </div>\r\n</div>\r\n```\r\n\r\nThe `bold` helper will add markup to make its text bold.\r\n\r\n```go\r\nraymond.RegisterHelper(\"bold\", func(options *raymond.Options) raymond.SafeString {\r\n    return raymond.SafeString(`<div class=\"mybold\">` + options.Fn() + \"</div>\")\r\n})\r\n```\r\n\r\nA helper evaluates the block content with current context by calling `options.Fn()`.\r\n\r\nIf you want to evaluate the block with another context, then use `options.FnWith(ctx)`, like this french version of built-in `with` block helper:\r\n\r\n```go\r\nraymond.RegisterHelper(\"avec\", func(context interface{}, options *raymond.Options) string {\r\n    return options.FnWith(context)\r\n})\r\n```\r\n\r\nWith that template:\r\n\r\n```html\r\n{{#avec obj.text}}{{this}}{{/avec}}\r\n```\r\n\r\n\r\n#### Conditional\r\n\r\nLet's write a french version of `if` block helper:\r\n\r\n```go\r\nsource := `{{#si yep}}YEP !{{/si}}`\r\n\r\nctx := map[string]interface{}{\"yep\": true}\r\n\r\nraymond.RegisterHelper(\"si\", func(conditional bool, options *raymond.Options) string {\r\n    if conditional {\r\n        return options.Fn()\r\n    }\r\n    return \"\"\r\n})\r\n```\r\n\r\nNote that as the first parameter of the helper is typed as `bool` an automatic conversion is made if corresponding context value is not a boolean. So this helper works with that context too:\r\n\r\n```go\r\nctx := map[string]interface{}{\"yep\": \"message\"}\r\n```\r\n\r\nHere, `\"message\"` is converted to `true` because it is an non-empty string. See `IsTrue()` function for more informations on boolean conversion.\r\n\r\n\r\n#### Else Block Evaluation\r\n\r\nWe can enhance the `si` block helper to evaluate the `else block` by calling `options.Inverse()` if conditional is false:\r\n\r\n```go\r\nsource := `{{#si yep}}YEP !{{else}}NOP !{{/si}}`\r\n\r\nctx := map[string]interface{}{\"yep\": false}\r\n\r\nraymond.RegisterHelper(\"si\", func(conditional bool, options *raymond.Options) string {\r\n    if conditional {\r\n        return options.Fn()\r\n    }\r\n    return options.Inverse()\r\n})\r\n```\r\n\r\nOutputs:\r\n```\r\nNOP !\r\n```\r\n\r\n\r\n#### Block Parameters\r\n\r\nIt's possible to receive named parameters from supporting helpers.\r\n\r\n```html\r\n{{#each users as |user userId|}}\r\n  Id: {{userId}} Name: {{user.name}}\r\n{{/each}}\r\n```\r\n\r\nIn this particular example, `user` will have the same value as the current context and `userId` will have the index/key value for the iteration.\r\n\r\nThis allows for nested helpers to avoid name conflicts.\r\n\r\nFor example:\r\n\r\n```html\r\n{{#each users as |user userId|}}\r\n  {{#each user.books as |book bookId|}}\r\n    User: {{userId}} Book: {{bookId}}\r\n  {{/each}}\r\n{{/each}}\r\n```\r\n\r\nWith this context:\r\n\r\n```go\r\nctx := map[string]interface{}{\r\n    \"users\": map[string]interface{}{\r\n        \"marcel\": map[string]interface{}{\r\n            \"books\": map[string]interface{}{\r\n                \"book1\": \"My first book\",\r\n                \"book2\": \"My second book\",\r\n            },\r\n        },\r\n        \"didier\": map[string]interface{}{\r\n            \"books\": map[string]interface{}{\r\n                \"bookA\": \"Good book\",\r\n                \"bookB\": \"Bad book\",\r\n            },\r\n        },\r\n    },\r\n}\r\n```\r\n\r\nOutputs:\r\n\r\n```html\r\n  User: marcel Book: book1\r\n  User: marcel Book: book2\r\n  User: didier Book: bookA\r\n  User: didier Book: bookB\r\n```\r\n\r\nAs you can see, the second block parameter is the map key. When using structs, it is the struct field name.\r\n\r\nWhen using arrays and slices, the second parameter is element index:\r\n\r\n```go\r\nctx := map[string]interface{}{\r\n    \"users\": []map[string]interface{}{\r\n        {\r\n            \"id\": \"marcel\",\r\n            \"books\": []map[string]interface{}{\r\n                {\"id\": \"book1\", \"title\": \"My first book\"},\r\n                {\"id\": \"book2\", \"title\": \"My second book\"},\r\n            },\r\n        },\r\n        {\r\n            \"id\": \"didier\",\r\n            \"books\": []map[string]interface{}{\r\n                {\"id\": \"bookA\", \"title\": \"Good book\"},\r\n                {\"id\": \"bookB\", \"title\": \"Bad book\"},\r\n            },\r\n        },\r\n    },\r\n}\r\n```\r\n\r\nOutputs:\r\n\r\n```html\r\n    User: 0 Book: 0\r\n    User: 0 Book: 1\r\n    User: 1 Book: 0\r\n    User: 1 Book: 1\r\n```\r\n\r\n\r\n### Helper Parameters\r\n\r\nWhen calling a helper in a template, raymond expects the same number of arguments as the number of helper function parameters.\r\n\r\nSo this template:\r\n\r\n```html\r\n{{add a}}\r\n```\r\n\r\nWith this helper:\r\n\r\n```go\r\nraymond.RegisterHelper(\"add\", func(val1, val2 int) string {\r\n    return strconv.Itoa(val1 + val2)\r\n})\r\n```\r\n\r\nWill simply panics, because we call the helper with one argument whereas it expects two.\r\n\r\n\r\n#### Automatic conversion\r\n\r\nLet's create a `concat` helper that expects two strings and concat them:\r\n\r\n```go\r\nsource := `{{concat a b}}`\r\n\r\nctx := map[string]interface{}{\r\n    \"a\": \"Jean\",\r\n    \"b\": \"Valjean\",\r\n}\r\n\r\nraymond.RegisterHelper(\"concat\", func(val1, val2 string) string {\r\n    return val1 + \" \" + val2\r\n})\r\n```\r\n\r\nEverything goes well, two strings are passed as arguments to the helper that outputs:\r\n\r\n```html\r\nJean VALJEAN\r\n```\r\n\r\nBut what happens if there is another type than `string` in the context ? For example:\r\n\r\n```go\r\nctx := map[string]interface{}{\r\n    \"a\": 10,\r\n    \"b\": \"Valjean\",\r\n}\r\n```\r\n\r\nActually, raymond perfoms automatic string conversion. So because the first parameter of the helper is typed as `string`, the first argument will be converted from the `10` integer to `\"10\"`, and the helper outputs:\r\n\r\n```html\r\n10 VALJEAN\r\n```\r\n\r\nNote that this kind of automatic conversion is done with `bool` type too, thanks to the `IsTrue()` function.\r\n\r\n\r\n### Options Argument\r\n\r\nIf a helper needs the `Options` argument, just add it as the end of helper parameters:\r\n\r\n```go\r\nraymond.RegisterHelper(\"add\", func(val1, val2 int, options *raymond.Options) string {\r\n    return strconv.Itoa(val1 + val2) + \" \" + options.ValueStr(\"bananas\")\r\n})\r\n```\r\n\r\nThanks to the `options` argument, helpers have access to the current evaluation context, to the `Hash` arguments, and they can manipulate the private data variables.\r\n\r\nThe `Options` argument is even necessary for Block Helpers to evaluate block and \"else block\".\r\n\r\n\r\n#### Context Values\r\n\r\nHelpers fetch current context values with `options.Value()` and `options.ValuesStr()`.\r\n\r\n`Value()` returns an `interface{}` and lets the helper do the type assertions whereas `ValueStr()` automatically converts the value to a `string`.\r\n\r\nFor example:\r\n\r\n```go\r\nsource := `{{concat a b}}`\r\n\r\nctx := map[string]interface{}{\r\n    \"a\":      \"Marcel\",\r\n    \"b\":      \"Beliveau\",\r\n    \"suffix\": \"FOREVER !\",\r\n}\r\n\r\nraymond.RegisterHelper(\"concat\", func(val1, val2 string, options *raymond.Options) string {\r\n    return val1 + \" \" + val2 + \" \" + options.ValueStr(\"suffix\")\r\n})\r\n```\r\n\r\nOutputs:\r\n\r\n```html\r\nMarcel Beliveau FOREVER !\r\n```\r\n\r\nHelpers can get the entire current context with `options.Ctx()` that returns an `interface{}`.\r\n\r\n\r\n#### Helper Hash Arguments\r\n\r\nHelpers access hash arguments with `options.HashProp()` and `options.HashStr()`.\r\n\r\n`HashProp()` returns an `interface{}` and lets the helper do the type assertions whereas `HashStr()` automatically converts the value to a `string`.\r\n\r\nFor example:\r\n\r\n```go\r\nsource := `{{concat suffix first=a second=b}}`\r\n\r\nctx := map[string]interface{}{\r\n    \"a\":      \"Marcel\",\r\n    \"b\":      \"Beliveau\",\r\n    \"suffix\": \"FOREVER !\",\r\n}\r\n\r\nraymond.RegisterHelper(\"concat\", func(suffix string, options *raymond.Options) string {\r\n    return options.HashStr(\"first\") + \" \" + options.HashStr(\"second\") + \" \" + suffix\r\n})\r\n```\r\n\r\nOutputs:\r\n\r\n```html\r\nMarcel Beliveau FOREVER !\r\n```\r\n\r\nHelpers can get the full hash with `options.Hash()` that returns a `map[string]interface{}`.\r\n\r\n\r\n#### Private Data\r\n\r\nHelpers access private data variables with `options.Data()` and `options.DataStr()`.\r\n\r\n`Data()` returns an `interface{}` and lets the helper do the type assertions whereas `DataStr()` automatically converts the value to a `string`.\r\n\r\nHelpers can get the entire current data frame with `options.DataFrame()` that returns a `*DataFrame`.\r\n\r\nFor helpers that need to inject their own private data frame, use `options.NewDataFrame()` to create the frame and `options.FnData()` to evaluate the block with that frame.\r\n\r\nFor example:\r\n\r\n```go\r\nsource := `{{#voodoo kind=a}}Voodoo is {{@magix}}{{/voodoo}}`\r\n\r\nctx := map[string]interface{}{\r\n    \"a\": \"awesome\",\r\n}\r\n\r\nraymond.RegisterHelper(\"voodoo\", func(options *raymond.Options) string {\r\n    // create data frame with @magix data\r\n    frame := options.NewDataFrame()\r\n    frame.Set(\"magix\", options.HashProp(\"kind\"))\r\n\r\n    // evaluates block with new data frame\r\n    return options.FnData(frame)\r\n})\r\n```\r\n\r\nHelpers that need to evaluate the block with a private data frame and a new context can call `options.FnCtxData()`.\r\n\r\n\r\n### Utilites\r\n\r\nIn addition to `Escape()`, raymond provides utility functions that can be usefull for helpers.\r\n\r\n\r\n#### `Str()`\r\n\r\n`Str()` converts its parameter to a `string`.\r\n\r\nBooleans:\r\n\r\n```go\r\nraymond.Str(3) + \" foos and \" + raymond.Str(-1.25) + \" bars\"\r\n// Outputs: \"3 foos and -1.25 bars\"\r\n```\r\n\r\nNumbers:\r\n\r\n``` go\r\n\"everything is \" + raymond.Str(true) + \" and nothing is \" + raymond.Str(false)\r\n// Outputs: \"everything is true and nothing is false\"\r\n```\r\n\r\nMaps:\r\n\r\n```go\r\nraymond.Str(map[string]string{\"foo\": \"bar\"})\r\n// Outputs: \"map[foo:bar]\"\r\n```\r\n\r\nArrays and Slices:\r\n\r\n```go\r\nraymond.Str([]interface{}{true, 10, \"foo\", 5, \"bar\"})\r\n// Outputs: \"true10foo5bar\"\r\n```\r\n\r\n\r\n#### `IsTrue()`\r\n\r\n`IsTrue()` returns the truthy version of its parameter.\r\n\r\nIt returns `false` when parameter is either:\r\n\r\n  - an empty array\r\n  - an empty slice\r\n  - an empty map\r\n  - `\"\"`\r\n  - `nil`\r\n  - `0`\r\n  - `false`\r\n\r\nFor all others values, `IsTrue()` returns `true`.\r\n\r\n\r\n## Context Functions\r\n\r\nIn addition to helpers, lambdas found in context are evaluated.\r\n\r\nFor example, that template and context:\r\n\r\n```go\r\nsource := \"I {{feeling}} you\"\r\n\r\nctx := map[string]interface{}{\r\n    \"feeling\": func() string {\r\n        rand.Seed(time.Now().UTC().UnixNano())\r\n\r\n        feelings := []string{\"hate\", \"love\"}\r\n        return feelings[rand.Intn(len(feelings))]\r\n    },\r\n}\r\n```\r\n\r\nRandomly renders `I hate you` or `I love you`.\r\n\r\nThose context functions behave like helper functions: they can be called with parameters and they can have an `Options` argument.\r\n\r\n\r\n## Partials\r\n\r\n### Template Partials\r\n\r\nYou can register template partials before execution:\r\n\r\n```go\r\ntpl := raymond.MustParse(\"{{> foo}} baz\")\r\ntpl.RegisterPartial(\"foo\", \"<span>bar</span>\")\r\n\r\nresult := tpl.MustExec(nil)\r\nfmt.Print(result)\r\n```\r\n\r\nOutput:\r\n\r\n```html\r\n<span>bar</span> baz\r\n```\r\n\r\nYou can register several partials at once:\r\n\r\n```go\r\ntpl := raymond.MustParse(\"{{> foo}} and {{> baz}}\")\r\ntpl.RegisterPartials(map[string]string{\r\n    \"foo\": \"<span>bar</span>\",\r\n    \"baz\": \"<span>bat</span>\",\r\n})\r\n\r\nresult := tpl.MustExec(nil)\r\nfmt.Print(result)\r\n```\r\n\r\nOutput:\r\n\r\n```html\r\n<span>bar</span> and <span>bat</span>\r\n```\r\n\r\n\r\n### Global Partials\r\n\r\nYou can registers global partials that will be accessible by all templates:\r\n\r\n```go\r\nraymond.RegisterPartial(\"foo\", \"<span>bar</span>\")\r\n\r\ntpl := raymond.MustParse(\"{{> foo}} baz\")\r\nresult := tpl.MustExec(nil)\r\nfmt.Print(result)\r\n```\r\n\r\nOr:\r\n\r\n```go\r\nraymond.RegisterPartials(map[string]string{\r\n    \"foo\": \"<span>bar</span>\",\r\n    \"baz\": \"<span>bat</span>\",\r\n})\r\n\r\ntpl := raymond.MustParse(\"{{> foo}} and {{> baz}}\")\r\nresult := tpl.MustExec(nil)\r\nfmt.Print(result)\r\n```\r\n\r\n\r\n### Dynamic Partials\r\n\r\nIt's possible to dynamically select the partial to be executed by using sub expression syntax.\r\n\r\nFor example, that template randomly evaluates the `foo` or `baz` partial:\r\n\r\n```go\r\ntpl := raymond.MustParse(\"{{> (whichPartial) }}\")\r\ntpl.RegisterPartials(map[string]string{\r\n    \"foo\": \"<span>bar</span>\",\r\n    \"baz\": \"<span>bat</span>\",\r\n})\r\n\r\nctx := map[string]interface{}{\r\n    \"whichPartial\": func() string {\r\n        rand.Seed(time.Now().UTC().UnixNano())\r\n\r\n        names := []string{\"foo\", \"baz\"}\r\n        return names[rand.Intn(len(names))]\r\n    },\r\n}\r\n\r\nresult := tpl.MustExec(ctx)\r\nfmt.Print(result)\r\n```\r\n\r\n\r\n### Partial Contexts\r\n\r\nIt's possible to execute partials on a custom context by passing in the context to the partial call.\r\n\r\nFor example:\r\n\r\n```go\r\ntpl := raymond.MustParse(\"User: {{> userDetails user }}\")\r\ntpl.RegisterPartial(\"userDetails\", \"{{firstname}} {{lastname}}\")\r\n\r\nctx := map[string]interface{}{\r\n    \"user\": map[string]string{\r\n        \"firstname\": \"Jean\",\r\n        \"lastname\":  \"Valjean\",\r\n    },\r\n}\r\n\r\nresult := tpl.MustExec(ctx)\r\nfmt.Print(result)\r\n```\r\n\r\nDisplays:\r\n\r\n```html\r\nUser: Jean Valjean\r\n```\r\n\r\n\r\n### Partial Parameters\r\n\r\nCustom data can be passed to partials through hash parameters.\r\n\r\nFor example:\r\n\r\n```go\r\ntpl := raymond.MustParse(\"{{> myPartial name=hero }}\")\r\ntpl.RegisterPartial(\"myPartial\", \"My hero is {{name}}\")\r\n\r\nctx := map[string]interface{}{\r\n    \"hero\": \"Goldorak\",\r\n}\r\n\r\nresult := tpl.MustExec(ctx)\r\nfmt.Print(result)\r\n```\r\n\r\nDisplays:\r\n\r\n```html\r\nMy hero is Goldorak\r\n```\r\n\r\n\r\n## Mustache\r\n\r\nHandlebars is a superset of [mustache](https://mustache.github.io) but it differs on those points:\r\n\r\n- Alternative delimiters are not supported\r\n- There is no recursive lookup\r\n\r\n\r\n## Limitations\r\n\r\nThese handlebars options are currently NOT implemented:\r\n\r\n- `compat` - enables recursive field lookup\r\n- `knownHelpers` - list of helpers that are known to exist (truthy) at template execution time\r\n- `knownHelpersOnly` - allows further optimzations based on the known helpers list\r\n- `trackIds` - include the id names used to resolve parameters for helpers\r\n- `noEscape` - disables HTML escaping globally\r\n- `strict` - templates will throw rather than silently ignore missing fields\r\n- `assumeObjects` - removes object existence checks when traversing paths\r\n- `preventIndent` - disables the auto-indententation of nested partials\r\n- `stringParams` - resolves a parameter to it's name if the value isn't present in the context stack\r\n\r\nThese handlebars features are currently NOT implemented:\r\n\r\n- raw block content is not passed as a parameter to helper\r\n- `blockHelperMissing` - helper called when a helper can not be directly resolved\r\n- `helperMissing` - helper called when a potential helper expression was not found\r\n- `@contextPath` - value set in `trackIds` mode that records the lookup path for the current context\r\n- `@level` - log level\r\n\r\n\r\n## Handlebars Lexer\r\n\r\nYou should not use the lexer directly, but for your information here is an example:\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n    \"fmt\"\r\n\r\n    \"github.com/aymerick/raymond/lexer\"\r\n)\r\n\r\nfunc main() {\r\n    source := \"You know {{nothing}} John Snow\"\r\n\r\n    output := \"\"\r\n\r\n    lex := lexer.Scan(source)\r\n    for {\r\n        // consume next token\r\n        token := lex.NextToken()\r\n\r\n        output += fmt.Sprintf(\" %s\", token)\r\n\r\n        // stops when all tokens have been consumed, or on error\r\n        if token.Kind == lexer.TokenEOF || token.Kind == lexer.TokenError {\r\n            break\r\n        }\r\n    }\r\n\r\n    fmt.Print(output)\r\n}\r\n```\r\n\r\nOutputs:\r\n\r\n```\r\nContent{\"You know \"} Open{\"{{\"} ID{\"nothing\"} Close{\"}}\"} Content{\" John Snow\"} EOF\r\n```\r\n\r\n\r\n## Handlebars Parser\r\n\r\nYou should not use the parser directly, but for your information here is an example:\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n    \"fmt\"\r\n\r\n    \"github.com/aymerick/raymond/ast\"\r\n    \"github.com/aymerick/raymond/parser\"\r\n)\r\n\r\nfu  nc main() {\r\n    source := \"You know {{nothing}} John Snow\"\r\n\r\n    // parse template\r\n    program, err := parser.Parse(source)\r\n    if err != nil {\r\n        panic(err)\r\n    }\r\n\r\n    // print AST\r\n    output := ast.Print(program)\r\n\r\n    fmt.Print(output)\r\n}\r\n```\r\n\r\nOutputs:\r\n\r\n```\r\nCONTENT[ 'You know ' ]\r\n{{ PATH:nothing [] }}\r\nCONTENT[ ' John Snow' ]\r\n```\r\n\r\n\r\n## Test\r\n\r\nTo run all tests:\r\n\r\n    $ go test ./...\r\n\r\nTo filter tests:\r\n\r\n    $ go test -run=\"Partials\"\r\n\r\nTo run all test and all benchmarks:\r\n\r\n    $ go test -bench . ./...\r\n\r\n\r\n## References\r\n\r\n  - <http://handlebarsjs.com/>\r\n  - <https://mustache.github.io/mustache.5.html>\r\n  - <https://github.com/golang/go/tree/master/src/text/template>\r\n  - <https://www.youtube.com/watch?v=HxaD_trXwRE>\r\n\r\n\r\n## Others Implementations\r\n\r\n- [handlebars.js](http://handlebarsjs.com) - javascript\r\n- [handlebars.java](https://github.com/jknack/handlebars.java) - java\r\n- [handlebars.rb](https://github.com/cowboyd/handlebars.rb) - ruby\r\n- [handlebars.php](https://github.com/XaminProject/handlebars.php) - php\r\n- [handlebars-objc](https://github.com/Bertrand/handlebars-objc) - Objective C\r\n- [rumblebars](https://github.com/nicolas-cherel/rumblebars) - rust\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}